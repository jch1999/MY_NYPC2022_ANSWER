//전체 색의 수,
//행별 전체 색의 수와 행에 존재하는 색마다의 수,
//열별 전체 색의 수와 열에 존재하는 색마다의 수를 비교하여
//줄(행 or 열)의 전체 색의 수와 색의 수가 일치하는 경우 해당 줄을 queue에 넣고
//해당 줄과 교차하는 줄의 해당 색에 대한 정보 변화(갯수 감소)
//일치하는 줄 지우기
//남은 줄들 가지고 반복

//삼중 반복문 아닌 거 같은데...
//교차하는 선에서 제외되는 색의 정보를 변경해야 하는데..
//런타임 초과가 뜨네...
//사중 반복문이었네...

//이중 백터로 만든 다음, [row_index][colorNum]에 색이 존재하는 col값을 저장
//이중 백터로 만든 다음, [col_index][colorNum]에 색이 존재하는 row값을 저장
//이러면 따로 갯수를 저장하는 배열 필요 없이 vector.size()를 호출하면 되기는 할 텐데..
//vector.erase였나? remove였나? 그걸로 지우면거고..
//사중 반복문을 없애야 하는데 이러면 되려나?
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>

#define FAST ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);

using namespace std;

const int colorCnt=7;

int main()
{
    FAST
    
    int row,col;//row - N | col - M
    cin>>row>>col;
    
    vector<vector<int>> matrix;//입력된 판
    vector<int> rowsColorCnt[row];//행에 속한 각 색의 수(색 별로 분리)
    vector<int> rowsTotalCnt(row);//행에 존재하는 색의 총 수
    vector<int> colsColorCnt[col];//열에 속한 각 색의 수
    vector<int> colsTotalCnt(col);//열에 존재하는 색의 총 수
    int colorSum=0;
    
    priority_queue<pair<pair<int,string>,pair<int,int>>> answer;
    
    matrix.resize(row);
    for(int i=0;i<row;i++)
    {
        matrix[i].resize(col);
        rowsColorCnt[i].resize(colorCnt+1);
    }
    for(int i=0;i<col;i++)
    {
        colsColorCnt[i].resize(colorCnt+1);
    }
    
    for(int i=0;i<row;i++)
    {
        for(int j=0;j<col;j++)
        {
            cin>>matrix[i][j];
            //0은 계산에 넣을 필요 없으므로 무시
            if(matrix[i][j]!=0)
            {
                rowsColorCnt[i][matrix[i][j]]++;
                rowsTotalCnt[i]++;
                colsColorCnt[j][matrix[i][j]]++;
                colsTotalCnt[j]++;
                colorSum++;
            }
        }
    }
    
    int cnt=0;
    while(colorSum!=0)
    {
        for(int i=0;i<row;i++)
        {
            for(int j=1;j<=colorCnt;j++)
            {
                if(rowsColorCnt[i][j]==0)
                    continue;
                
                if(rowsTotalCnt[i]==rowsColorCnt[i][j])
                {
                    colorSum-=rowsTotalCnt[i];
                    rowsTotalCnt[i]=0;
                    
                    for(int k=0;k<col;j++)
                    {
                        if(matrix[i][k]==j)
                        {
                            colsTotalCnt[k]--;
                            colsColorCnt[k][j]--;
                        }
                    }
                    
                    answer.push({{cnt++,"H"},{i+1,j}});
                }
            }
        }
        
        for(int i=0;i<col;i++)
        {
            for(int j=1;j<=colorCnt;j++)
            {
                if(rowsColorCnt[i][j]==0)
                    continue;
                
                if(colsTotalCnt[i]==colsColorCnt[i][j])
                {
                    colorSum-=colsTotalCnt[i];
                    colsTotalCnt[i]=0;
                    for(int k=0;k<row;j++)
                    {
                        if(matrix[k][i]==j)
                        {
                            rowsTotalCnt[k]--;
                            rowsColorCnt[k][j]--;
                        }
                    }
                    
                    answer.push({{cnt++,"V"},{i+1,j}});
                }
            }
        }
    }
    
    while(!answer.empty())
    {
        pair<pair<int,string>,pair<int,int>> pop=answer.top();
        answer.pop();
        cout<<pop.first.second<<" "<<pop.second.first<<" "<<pop.second.second<<'\n';
    }
    return 0;
}
